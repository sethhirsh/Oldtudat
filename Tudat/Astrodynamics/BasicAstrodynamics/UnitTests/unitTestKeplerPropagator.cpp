/*!   Copyright (c) 2010-2012 Delft University of Technology.
 *
 *    This software is protected by national and international copyright.
 *    Any unauthorized use, reproduction or modification is unlawful and
 *    will be prosecuted. Commercial and non-private application of the
 *    software in any form is strictly prohibited unless otherwise granted
 *    by the authors.
 *
 *    The code is provided without any warranty; without even the implied
 *    warranty of merchantibility or fitness for a particular purpose.
 *
 *    Changelog
 *      YYMMDD    Author            Comment
 *      110216    K. Kumar          First creation of code.
 *      110217    E. Iorfida        Minor changes made.
 *      110221    K. Kumar          Updated variable-naming to comply with protocol.
 *      110920    K. Kumar          Corrected simple errors outlined by M. Persson.
 *      120215    K. Kumar          Updated to use new propagateKeplerOrbit() function;
 *                                  Boostified unit test; added new unit tests based on ODTBX.
 *      120217    K. Kumar          Updated computeModuloForSignedValues() to computeModulo() from
 *                                  Tudat Core.
 *
 *    References
 *      Melman, J. Propagate software, J.C.P.Melman@tudelft.nl, 2010.
 *      NASA, Goddard Spaceflight Center. Orbit Determination Toolbox (ODTBX), NASA - GSFC Open
 *          Source Software, http://opensource.gsfc.nasa.gov/projects/ODTBX/, last accessed:
 *          31st January, 2012.
 *
 */

#define BOOST_TEST_MAIN

#include <Eigen/Core>
#include <fstream>
#include <iostream>
#include <limits>
#include <map>
#include <boost/test/floating_point_comparison.hpp>
#include <boost/test/unit_test.hpp>
#include <TudatCore/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.h>
#include <TudatCore/Basics/testMacros.h>
#include <TudatCore/Mathematics/BasicMathematics/basicMathematicsFunctions.h>
#include <TudatCore/Mathematics/BasicMathematics/mathematicalConstants.h>
#include "Tudat/Astrodynamics/BasicAstrodynamics/keplerPropagator.h"
#include "Tudat/InputOutput/basicInputOutput.h"

namespace tudat
{
namespace unit_tests
{

// Typedef for propagation history.
typedef std::map < double, Eigen::VectorXd > PropagationHistory;

//! Get ODTBX benchmark data.
PropagationHistory getODTBXBenchmarkData( )
{
    // Declare benchmark pragation history.
    PropagationHistory benchmarkPropagationHistory;

    // Populate benchmark propagation history.
    Eigen::VectorXd stateInKeplerianElements( 6 );

    stateInKeplerianElements << 42165.3431351313e3, 0.26248354351331, 0.30281462522101,
            4.71463172847351, 4.85569272927819, 2.37248926702153;

    // Set time step.
    double timeStep = 8640.0;

    for ( unsigned int i = 0; i < 11; i++ )
    {
        benchmarkPropagationHistory[ static_cast< double >( i ) * timeStep ]
                = stateInKeplerianElements;
    }

    benchmarkPropagationHistory[ 1.0 * timeStep ]( 5 ) = 2.79722436211144;
    benchmarkPropagationHistory[ 2.0 * timeStep ]( 5 ) = 3.18337407409023;
    benchmarkPropagationHistory[ 3.0 * timeStep ]( 5 ) = 3.57400974200765;
    benchmarkPropagationHistory[ 4.0 * timeStep ]( 5 ) = 4.01425565759545;
    benchmarkPropagationHistory[ 5.0 * timeStep ]( 5 ) = 4.57232665706546;
    benchmarkPropagationHistory[ 6.0 * timeStep ]( 5 ) = 5.35956850972672;
    benchmarkPropagationHistory[ 7.0 * timeStep ]( 5 ) = 0.137251905665217;
    benchmarkPropagationHistory[ 8.0 * timeStep ]( 5 ) = 1.14521863765007;
    benchmarkPropagationHistory[ 9.0 * timeStep ]( 5 ) = 1.86433634881636;
    benchmarkPropagationHistory[ 10.0 * timeStep ]( 5 ) = 2.38486787064101;

    return benchmarkPropagationHistory;
}

//! Test if the orbital period of a Kepler orbit is computed correctly.
BOOST_AUTO_TEST_CASE( testPropagateKeplerOrbit )
{
    // Case 1: Comparison of propagateKeplerOrbit() output with benchmark data from (Melman, 2010).
    {
        // Load benchmark data.
        // This data originates from J. Melman and is generated by the software package Propagate.

        // Load file with benchmark data.
        std::string relativePathToBenchmarkData
                = "Astrodynamics/BasicAstrodynamics/UnitTests/twoBodyKeplerData.dat";

        std::string absolutePathToBenchmarkData = tudat::input_output::getTudatRootPath( )
                + relativePathToBenchmarkData;

        std::ifstream twoBodyKeplerBenchmarkFile( absolutePathToBenchmarkData.c_str( ) );

        // Check if file could be opened.
        if ( !twoBodyKeplerBenchmarkFile )
        {
            std::cerr << "Error: Two-body Kepler benchmark data file could not be opened."
                      << std::endl;
            std::cerr << absolutePathToBenchmarkData << std::endl;
        }

        // Create propagation history map for benchmark data to be stored in.
        PropagationHistory benchmarkKeplerPropagationHistory;

        // Declare epoch.
        double epoch = -0.0;

        // Initialize counter.
        unsigned int twoBodyKeplerDataCounter = 0;

        // Populate propagation history map with benchmark data from file.
        while ( !twoBodyKeplerBenchmarkFile.eof( ) )
        {
            // Store elapsed time which is given in first coloumn.
            twoBodyKeplerBenchmarkFile >> epoch;

            Eigen::VectorXd benchmarkState( 6 );

            // Store state date from file.
            for ( unsigned int i = 0; i < 6; i++ )
            {
                twoBodyKeplerBenchmarkFile >> benchmarkState( i );
            }

            // Store data (convert from km and km/s to m and m/s)
            benchmarkKeplerPropagationHistory[ epoch ] = benchmarkState * 1000.0;

            // Increment counter.
            twoBodyKeplerDataCounter++;
        }

        // Close benchmark data file.
        twoBodyKeplerBenchmarkFile.close( );

        // Run Kepler propagator simulation.

        // Set Earth gravitational parameter [m^3 s^-2].
        double earthGravitationalParameter = 3.986004415e14;

        // Set initial state in Cartesian elements [m, m/s].
        Eigen::VectorXd initialState = ( *benchmarkKeplerPropagationHistory.begin( ) ).second;

        // Convert initial state to Keplerian elements.
        Eigen::VectorXd initialStateInKeplerianElements = orbital_element_conversions::
                convertCartesianToKeplerianElements(
                    initialState, earthGravitationalParameter );

        // Set time step.
        double timeStep = 3600.0;

        // Create expected propagation history in Keplerian elements.
        PropagationHistory expectedPropagationHistory;

        // Conversion loop counter.
        unsigned int counter = 0;

        // Convert expected states from Cartesian elements to Keplerian elements.
        for ( PropagationHistory::iterator iteratorBenchmarkData
              = benchmarkKeplerPropagationHistory.begin( );
              iteratorBenchmarkData != benchmarkKeplerPropagationHistory.end( );
              iteratorBenchmarkData++ )
        {
            expectedPropagationHistory[ counter * timeStep ]
                    = orbital_element_conversions::convertCartesianToKeplerianElements(
                        iteratorBenchmarkData->second,
                        earthGravitationalParameter );

            counter++;
        }

        // Create computed propagation history in Keplerian elements.
        PropagationHistory computedPropagationHistory;
        computedPropagationHistory[ 0.0 ] = expectedPropagationHistory[ 0.0 ];

        for ( unsigned int i = 1; i < benchmarkKeplerPropagationHistory.size( ); i++ )
        {
            computedPropagationHistory[ static_cast< double >( i ) * timeStep ]
                    = orbital_element_conversions::propagateKeplerOrbit(
                        expectedPropagationHistory[ static_cast< double >( i - 1 ) * timeStep ],
                        static_cast< double >( i - 1 ) * timeStep,
                        static_cast< double >( i ) * timeStep, earthGravitationalParameter,
                        1.0e-10 );

            // Check that computed results match expected results.
            BOOST_CHECK_CLOSE_FRACTION(
                        mathematics::computeModulo(
                            computedPropagationHistory[ static_cast< double >( i ) * timeStep ]( 5 ),
                            2.0 * mathematics::PI ),
                        expectedPropagationHistory[ static_cast< double >( i ) * timeStep ]( 5 ),
                        1.0e-8 );
        }
    }

    // Case 2: Comparison of kepprop2b() test output from (GSFC, 2012) using modulo option.
    {
        // Create expected propagation history.
        PropagationHistory expectedPropagationHistory = getODTBXBenchmarkData( );

        // Set Earth gravitational parameter [m^3 s^-2].
        double earthGravitationalParameter = 398600.4415e9;

        // Set time step for ODTBX benchmark data.
        double timeStep = 8640.0;

        // Compute propagation history.
        PropagationHistory computedPropagationHistory;
        computedPropagationHistory[ 0.0 ] = expectedPropagationHistory[ 0.0 ];

        for ( unsigned int i = 1; i < expectedPropagationHistory.size( ); i++ )
        {
            computedPropagationHistory[ static_cast< double >( i ) * timeStep ]
                    = orbital_element_conversions::propagateKeplerOrbit(
                        computedPropagationHistory[ static_cast< double >( i - 1 ) * timeStep ],
                        static_cast< double >( i - 1 ) * timeStep,
                        static_cast< double >( i ) * timeStep, earthGravitationalParameter,
                        1.0e-10 );

            computedPropagationHistory[ static_cast< double >( i ) * timeStep ]( 5 )
                    = mathematics::computeModulo(
                        computedPropagationHistory[ static_cast< double >( i ) * timeStep ]( 5 ),
                        2.0 * mathematics::PI );

            // Check that computed results match expected results.
            TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                        computedPropagationHistory[ static_cast< double >( i ) * timeStep ],
                        expectedPropagationHistory[ static_cast< double >( i ) * timeStep ],
                        1.0e-13 );
        }
    }

    // Case 3: Comparison of kepprop2b() test output from (GSFC, 2012) without using modulo option.
    {
        // Create expected propagation history.
        PropagationHistory expectedPropagationHistory = getODTBXBenchmarkData( );

        // Set Earth gravitational parameter [m^3 s^-2].
        double earthGravitationalParameter = 398600.4415e9;

        // Set time step for ODTBX benchmark data.
        double timeStep = 8640.0;

        // Compute propagation history.
        PropagationHistory computedPropagationHistory;
        computedPropagationHistory[ 0.0 ] = expectedPropagationHistory[ 0.0 ];

        for ( unsigned int i = 1; i < expectedPropagationHistory.size( ); i++ )
        {
            computedPropagationHistory[ static_cast< double >( i ) * timeStep ]
                    = orbital_element_conversions::propagateKeplerOrbit(
                        computedPropagationHistory[ static_cast< double >( i - 1 ) * timeStep ],
                        static_cast< double >( i - 1 ) * timeStep,
                        static_cast< double >( i ) * timeStep, earthGravitationalParameter,
                        1.0e-10, false );

            computedPropagationHistory[ static_cast< double >( i ) * timeStep ]( 5 )
                    = mathematics::computeModulo(
                        computedPropagationHistory[ static_cast< double >( i ) * timeStep ]( 5 ),
                        2.0 * mathematics::PI );

            // Check that computed results match expected results.
            TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                        computedPropagationHistory[ static_cast< double >( i ) * timeStep ],
                        expectedPropagationHistory[ static_cast< double >( i ) * timeStep ],
                        1.0e-13 );
        }
    }

    // Case 4: Comparison of kepprop2b() test output from (GSFC, 2012), propagating backwards.
    {
        // Create expected propagation history.
        PropagationHistory expectedPropagationHistory = getODTBXBenchmarkData( );

        // Set Earth gravitational parameter [m^3 s^-2].
        double earthGravitationalParameter = 398600.4415e9;

        // Set time step for ODTBX benchmark data.
        double timeStep = 8640.0;

        // Compute propagation history.
        PropagationHistory computedPropagationHistory;
        computedPropagationHistory[ 10.0 * 8640.0 ] = expectedPropagationHistory[ 10.0 * 8640.0 ];

        for ( unsigned int i = expectedPropagationHistory.size( ) - 2; i == 0; i-- )
        {
            computedPropagationHistory[ static_cast< double >( i ) * timeStep ]
                    = orbital_element_conversions::propagateKeplerOrbit(
                        computedPropagationHistory[ static_cast< double >( i + 1 ) * timeStep ],
                        static_cast< double >( i + 1 ) * timeStep,
                        static_cast< double >( i ) * timeStep, earthGravitationalParameter,
                        1.0e-10, false );

            computedPropagationHistory[ static_cast< double >( i ) * timeStep ]( 5 )
                    = mathematics::computeModulo(
                        computedPropagationHistory[ static_cast< double >( i ) * timeStep ]( 5 ),
                        2.0 * mathematics::PI );

            // Check that computed results match expected results.
            TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                        computedPropagationHistory[ static_cast< double >( i ) * timeStep ],
                        expectedPropagationHistory[ static_cast< double >( i ) * timeStep ],
                        1.0e-13 );
        }
    }
}

} // namespace unit_tests
} // namespace tudat